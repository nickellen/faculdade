 !!!!!!!! Somar dois inteiros e analisar a resposta no debugger do Bochs
		    

    # character to print
    mov $2, %ax
    mov $5, %bx
    
    add %bx, %ax
    
    hlt
   

!!!!!!!!  Exibir uma linha cheia de caracteres '0'
    
    loop:
    	
	movb $'0',%al 		# read character
	
	movb $0x0e,%ah 		# display character
	int $0x10 
	
	sub $1, %bl
	
	cmpb $ 0, %bl
	je fim
	
	jmp loop
    		
    
!!!!!!! Faça uma moldura na tela utilizando os caracteres da tabela ASCII para molduras de tela
    (╚, ╔, ═, ...) .
    
    
    
    movb $0, %bl
    movb $0, %bh  
    
    linhaIni:
    	
	movb $61,%al 		
	
	movb $0x0e,%ah 	
	int $0x10 
	
	
	cmpb $ 5, %bh
	add $1, %bl
	
	cmpb $ 80, %bl
	je colunaIni
	
	jmp linhaIni
	
	
     linhaFim:
    	
	movb $61,%al 		
	
	movb $0x0e,%ah 		
	int $0x10 
	
	sub $1, %bl
	
	cmpb $ 0, %bl
	je fim
	
	jmp linhaFim
	
  
    colunaIni:
    	
    	movb $124,%al 		
	
	movb $0x0e,%ah 		
	int $0x10 
	
	sub $1, %bl
	
	jmp preenche
	

     preenche:
	
	movb $32,%al 		
	
	movb $0x0e,%ah 		
	int $0x10 
	
	sub $1, %bl
	
	cmpb $ 1, %bl
	je colunaFim
	
	jmp preenche
	
	
    colunaFim:
    	
    	movb $124,%al 		
	
	movb $0x0e,%ah 	
	int $0x10 
	
	sub $1, %bl
	
	movb $80, %bl
	
	add $1, %bh
	
	cmpb $ 5, %bh
	je linhaFim
	
	jmp colunaIni
		
    fim:
    	hlt
    	jmp fim
    	
    	
    
  !!!!!!!  Ler caracteres via teclado e exibí-los na tela (um a um) (utilize a int 0x16 para leitura de caracteres via teclado)
    
    loop:
    	
    	
	movb $0x00,%ah 		# read character
	int $0x16 		# keyboard mode
	
	movb $0x0e,%ah 		# display character
	int $0x10 
	
	jmp loop
    
    
    
!!!!!!!---Ler caracteres via teclado e exibí-los na tela (um a um) até que a sequência exit seja digitada (utilize a int 0x16 para leitura de caracteres via teclado) (sugestão: utilizar uma estratégia baseada em automato)

    
# generate 16-bit code
.code16 			   
# executable code location
.text 				   

.globl _start

# entry point
_start:				    

loopE:
    	
	movb $0x00,%ah 		# ler character , vai pro al
	int $0x16 		# keyboard mode
	
	movb $0x0e,%ah 		# imprimir character
	int $0x10 
	
	cmp $101, %al		# comparar com e
	je loopX
	
	
	jmp loopE

loopX:
	
	movb $0x00,%ah 		# ler character , vai pro al
	int $0x16 		# keyboard mode
	
	movb $0x0e,%ah 		# imprimir character
	int $0x10 
	
	cmp $120, %al		# comparar com x
	je loopI
	
	cmp $101, %al		# comparar com e
	je loopX
	
	jmp loopE
	
loopI:
	
	movb $0x00,%ah 		# ler character , vai pro al
	int $0x16 		# keyboard mode
	
	movb $0x0e,%ah 		# imprimir character
	int $0x10 
	
	cmp $105, %al		# comparar com e
	je loopT
	
	
	jmp loopE


loopT:
	
	movb $0x00,%ah 		# ler character , vai pro al
	int $0x16 		# keyboard mode
	
	movb $0x0e,%ah 		# imprimir character
	int $0x10 
	
	cmp $116, %al		# comparar com e
	je fimloop
	
	
	jmp loopE
	
fimloop:

    hlt
    jmp fimloop

    
    # mov to 510th byte from 0 pos
    . = _start + 510	    
    
    # MBR boot signature 
    .byte 0x55		        
    # MBR boot signature 
    .byte 0xaa		        
    
    
